import { db } from '../db';
import { gitCommits, changelogs, changelogEntries } from '../db/schema';
import { eq, and, or } from 'drizzle-orm';
import { GitCommitParser, GitTag } from '../services/gitCommitParser';
import { CommitCategorizationService } from '../services/commitCategorizationService';
import { AutoChangelogService } from '../services/autoChangelogService';

/**
 * Comprehensive script to rebuild changelog from complete Git history
 * This will:
 * 1. Clear all existing auto-generated changelog entries and git commits
 * 2. Process ALL git commits from repository history
 * 3. Handle git tags as release boundaries
 * 4. Create appropriate versioned changelogs or single "Unreleased" changelog
 */
class ChangelogHistoryRebuilder {
  private gitParser: GitCommitParser;
  private categorizer: CommitCategorizationService;
  private autoService: AutoChangelogService;

  constructor(repoPath?: string) {
    this.gitParser = new GitCommitParser(repoPath);
    this.categorizer = new CommitCategorizationService();
    this.autoService = new AutoChangelogService();
  }

  /**
   * Main method to rebuild changelog from complete git history
   */
  async rebuildFromHistory(): Promise<void> {
    try {
      console.log('üöÄ Starting complete changelog rebuild from Git history...');

      // Step 1: Clear existing auto-generated data
      await this.clearExistingAutoGeneratedData();

      // Step 2: Get all git tags
      const tags = await this.getAllGitTags();
      console.log(`üè∑Ô∏è Found ${tags.length} git tags`);

      // Step 3: Get all commits from git history
      const allCommits = await this.getAllCommitsFromHistory();
      console.log(`üìù Found ${allCommits.length} total commits in history`);

      // Step 4: Categorize all commits
      const categorizedCommits = this.categorizer.categorizeCommits(allCommits);
      const publicCommits = categorizedCommits.filter(commit => commit.isPublic);
      console.log(`üåç ${publicCommits.length} commits are public and will be included in changelog`);

      // Step 5: Store all commits in database
      await this.storeAllCommitsInDatabase(categorizedCommits);

      // Step 6: Create changelogs based on git tags or single unreleased
      if (tags.length > 0) {
        await this.createVersionedChangelogsFromTags(tags, publicCommits);
      } else {
        await this.createSingleUnreleasedChangelog(publicCommits);
      }

      console.log('‚úÖ Changelog rebuild completed successfully!');

    } catch (error) {
      console.error('‚ùå Error rebuilding changelog from history:', error);
      throw error;
    }
  }

  /**
   * Clear all existing auto-generated changelog entries and git commits
   */
  private async clearExistingAutoGeneratedData(): Promise<void> {
    console.log('üßπ Clearing existing auto-generated data...');

    // Get all git tags to know which versions to clear
    const tags = await this.getAllGitTags();
    const tagVersions = tags.map(tag => tag.name.replace(/^v/, ''));

    // First, get changelogs that match git tag versions or are "Unreleased"
    const versionsToDelete = ['Unreleased', ...tagVersions];
    const changelogsToDelete = await db
      .select()
      .from(changelogs)
      .where(
        or(...versionsToDelete.map(version => eq(changelogs.version, version)))
      );

    // Delete all changelog entries for these changelogs (to avoid foreign key constraints)
    for (const changelog of changelogsToDelete) {
      const deletedEntries = await db
        .delete(changelogEntries)
        .where(eq(changelogEntries.changelogId, changelog.id));

      if (deletedEntries.changes && deletedEntries.changes > 0) {
        console.log(`   Deleted ${deletedEntries.changes} entries for changelog: ${changelog.version}`);
      }
    }

    // Now delete the changelogs themselves
    for (const version of versionsToDelete) {
      try {
        const deletedChangelogs = await db
          .delete(changelogs)
          .where(eq(changelogs.version, version));

        if (deletedChangelogs.changes && deletedChangelogs.changes > 0) {
          console.log(`   Deleted changelog for version: ${version}`);
        }
      } catch (error) {
        console.warn(`   ‚ö†Ô∏è Could not delete changelog for version ${version}:`, error);
      }
    }

    // Delete all git commits from database (they will be re-imported)
    const deletedCommits = await db.delete(gitCommits);
    console.log(`   Deleted ${deletedCommits.changes || 0} git commits from database`);
  }

  /**
   * Get all git tags from the repository
   */
  private async getAllGitTags(): Promise<GitTag[]> {
    try {
      return await this.gitParser.getAllTags();
    } catch (error) {
      console.warn('‚ö†Ô∏è Could not fetch git tags:', error);
      return [];
    }
  }

  /**
   * Get ALL commits from git history (not just recent ones)
   */
  private async getAllCommitsFromHistory(): Promise<any[]> {
    try {
      // Get all commits without any 'since' parameter to get complete history
      const commits = await this.gitParser.parseCommits({
        maxCount: 1000, // Increase limit to get more history
        includeMerges: false,
        // No 'since' parameter to get all commits
      });

      return commits;
    } catch (error) {
      console.error('Error getting all commits from history:', error);
      throw error;
    }
  }

  /**
   * Store all commits in the database
   */
  private async storeAllCommitsInDatabase(commits: any[]): Promise<void> {
    console.log(`üíæ Storing ${commits.length} commits in database...`);

    for (const commit of commits) {
      try {
        await db.insert(gitCommits).values({
          hash: commit.hash,
          shortHash: commit.shortHash,
          author: commit.author,
          authorEmail: commit.authorEmail,
          date: commit.date,
          message: commit.message,
          subject: commit.subject,
          body: commit.body,
          filesChanged: JSON.stringify(commit.filesChanged || []),
          insertions: commit.insertions || 0,
          deletions: commit.deletions || 0,
          category: commit.category,
          isBreakingChange: commit.isBreakingChange,
          isPublic: commit.isPublic,
          processedAt: new Date(),
          createdAt: new Date(),
        });
      } catch (error) {
        // Skip duplicates or other errors
        console.warn(`‚ö†Ô∏è Failed to store commit ${commit.shortHash}:`, error);
      }
    }

    console.log('‚úÖ All commits stored in database');
  }

  /**
   * Create versioned changelogs based on git tags
   */
  private async createVersionedChangelogsFromTags(tags: GitTag[], publicCommits: any[]): Promise<void> {
    console.log('üè∑Ô∏è Creating versioned changelogs from git tags...');

    if (tags.length === 0) {
      await this.createSingleUnreleasedChangelog(publicCommits);
      return;
    }

    // Sort tags by date (newest first)
    const sortedTags = [...tags].sort((a, b) => b.date.getTime() - a.date.getTime());

    // Create changelogs for each tag
    for (let i = 0; i < sortedTags.length; i++) {
      const currentTag = sortedTags[i];
      const previousTag = sortedTags[i + 1]; // Previous tag (older)

      console.log(`üìã Creating changelog for tag: ${currentTag.name}`);

      // Get commits between this tag and the previous tag (or from beginning)
      const tagCommits = await this.getCommitsForTag(currentTag, previousTag, publicCommits);

      if (tagCommits.length > 0) {
        await this.createChangelogForTag(currentTag, tagCommits);
      }
    }

    // Create "Unreleased" changelog for commits after the latest tag
    const latestTag = sortedTags[0];
    const unreleasedCommits = await this.getCommitsAfterTag(latestTag, publicCommits);

    if (unreleasedCommits.length > 0) {
      console.log('üìã Creating "Unreleased" changelog for commits after latest tag');
      await this.createSingleUnreleasedChangelog(unreleasedCommits);
    }
  }

  /**
   * Get commits that belong to a specific tag using git rev-list
   */
  private async getCommitsForTag(currentTag: GitTag, previousTag: GitTag | undefined, allCommits: any[]): Promise<any[]> {
    try {
      // Use git to get the actual commits between tags
      const range = previousTag ? `${previousTag.name}..${currentTag.name}` : currentTag.name;
      const commitsInRange = await this.gitParser.getCommitsBetweenTags(previousTag?.name, currentTag.name);

      // Match with our categorized commits
      const commitHashes = new Set(commitsInRange.map(c => c.hash));
      return allCommits.filter(commit => commitHashes.has(commit.hash));
    } catch (error) {
      console.warn(`‚ö†Ô∏è Failed to get commits for tag ${currentTag.name}, falling back to date-based filtering:`, error);

      // Fallback to date-based filtering
      const tagDate = currentTag.date;
      const previousTagDate = previousTag ? previousTag.date : new Date(0);

      return allCommits.filter(commit => {
        const commitDate = new Date(commit.date);
        return commitDate <= tagDate && commitDate > previousTagDate;
      });
    }
  }

  /**
   * Get commits that come after the latest tag (unreleased)
   */
  private async getCommitsAfterTag(latestTag: GitTag, allCommits: any[]): Promise<any[]> {
    try {
      // Get commits after the latest tag
      const commitsAfterTag = await this.gitParser.getCommitsBetweenTags(latestTag.name, 'HEAD');

      // Match with our categorized commits
      const commitHashes = new Set(commitsAfterTag.map(c => c.hash));
      return allCommits.filter(commit => commitHashes.has(commit.hash));
    } catch (error) {
      console.warn(`‚ö†Ô∏è Failed to get commits after tag ${latestTag.name}, falling back to date-based filtering:`, error);

      // Fallback to date-based filtering
      const tagDate = latestTag.date;
      return allCommits.filter(commit => {
        const commitDate = new Date(commit.date);
        return commitDate > tagDate;
      });
    }
  }

  /**
   * Create a changelog for a specific git tag
   */
  private async createChangelogForTag(tag: GitTag, commits: any[]): Promise<void> {
    try {
      // Create the changelog
      const [changelog] = await db.insert(changelogs).values({
        version: tag.name.replace(/^v/, ''), // Remove 'v' prefix if present
        title: tag.message || `Release ${tag.name}`,
        description: `Release ${tag.name} containing ${commits.length} changes.`,
        releaseDate: tag.date,
        isPublished: true,
        publishedAt: tag.date,
        createdBy: 1, // System user
        createdAt: new Date(),
        updatedAt: new Date(),
      }).returning();

      // Add commits as changelog entries
      let sortOrder = 1;
      for (const commit of commits) {
        await db.insert(changelogEntries).values({
          changelogId: changelog.id,
          category: commit.category,
          title: commit.cleanTitle,
          description: commit.cleanDescription || commit.cleanTitle,
          sortOrder: sortOrder++,
          gitCommitHash: commit.hash,
          isAutoGenerated: true,
          createdAt: new Date(),
        });
      }

      console.log(`‚úÖ Created changelog for ${tag.name} with ${commits.length} entries`);
    } catch (error) {
      console.error(`‚ùå Failed to create changelog for tag ${tag.name}:`, error);
    }
  }

  /**
   * Create a single "Unreleased" changelog with all public commits
   */
  private async createSingleUnreleasedChangelog(publicCommits: any[]): Promise<void> {
    console.log('üìã Creating single "Unreleased" changelog with all commits...');

    if (publicCommits.length === 0) {
      console.log('‚ÑπÔ∏è No public commits to add to changelog');
      return;
    }

    // Create or get unreleased changelog
    const unreleasedChangelog = await this.autoService.getOrCreateUnreleasedChangelog();

    // Add all public commits as changelog entries
    let entriesCreated = 0;
    for (const commit of publicCommits) {
      try {
        await db.insert(changelogEntries).values({
          changelogId: unreleasedChangelog.id,
          category: commit.category,
          title: commit.cleanTitle,
          description: commit.cleanDescription || commit.cleanTitle,
          sortOrder: entriesCreated + 1,
          gitCommitHash: commit.hash,
          isAutoGenerated: true,
          createdAt: new Date(),
        });
        entriesCreated++;
      } catch (error) {
        console.warn(`‚ö†Ô∏è Failed to create changelog entry for commit ${commit.shortHash}:`, error);
      }
    }

    console.log(`‚úÖ Created ${entriesCreated} changelog entries in "Unreleased" changelog`);
  }
}

/**
 * Main execution function
 */
async function main() {
  try {
    const rebuilder = new ChangelogHistoryRebuilder();
    await rebuilder.rebuildFromHistory();

    console.log('\nüéâ Changelog rebuild completed successfully!');
    console.log('üìã All git commits have been processed into changelog entries');
    console.log('üîÑ The continuous changelog system will now track new commits going forward');

  } catch (error) {
    console.error('\n‚ùå Changelog rebuild failed:', error);
    process.exit(1);
  }
}

// Run the script if called directly
if (require.main === module) {
  main();
}

export { ChangelogHistoryRebuilder };
