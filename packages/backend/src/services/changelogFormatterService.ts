import { db } from '../db';
import { changelogs, changelogEntries } from '../db/schema';
import { eq, desc } from 'drizzle-orm';
import { CommitCategorizationService, CommitCategory } from './commitCategorizationService';

export interface ChangelogFormatOptions {
  includeMetadata?: boolean;
  includeCommitHashes?: boolean;
  groupByCategory?: boolean;
  customTemplate?: string;
}

export interface FormattedChangelog {
  version: string;
  title: string;
  description?: string;
  releaseDate: Date;
  entries: FormattedChangelogEntry[];
}

export interface FormattedChangelogEntry {
  category: CommitCategory;
  title: string;
  description: string;
  commitHash?: string;
  isAutoGenerated: boolean;
}

export class ChangelogFormatterService {
  /**
   * Generate markdown changelog for a specific version
   */
  async generateMarkdown(
    version: string,
    options: ChangelogFormatOptions = {}
  ): Promise<string> {
    const changelog = await this.getChangelogData(version);
    if (!changelog) {
      throw new Error(`Changelog not found for version ${version}`);
    }

    return this.formatAsMarkdown(changelog, options);
  }

  /**
   * Generate markdown for all published changelogs
   */
  async generateFullMarkdown(options: ChangelogFormatOptions = {}): Promise<string> {
    const changelogs = await this.getAllChangelogData();
    
    let markdown = '# Changelog\n\n';
    markdown += 'All notable changes to this project will be documented in this file.\n\n';
    markdown += 'The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\n';
    markdown += 'and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n';

    for (const changelog of changelogs) {
      markdown += this.formatAsMarkdown(changelog, options) + '\n\n';
    }

    return markdown.trim();
  }

  /**
   * Generate JSON format changelog
   */
  async generateJSON(version?: string): Promise<FormattedChangelog | FormattedChangelog[]> {
    if (version) {
      const changelog = await this.getChangelogData(version);
      if (!changelog) {
        throw new Error(`Changelog not found for version ${version}`);
      }
      return changelog;
    } else {
      return await this.getAllChangelogData();
    }
  }

  /**
   * Generate RSS feed format
   */
  async generateRSS(): Promise<string> {
    const changelogs = await this.getAllChangelogData();
    
    let rss = '<?xml version="1.0" encoding="UTF-8"?>\n';
    rss += '<rss version="2.0">\n';
    rss += '  <channel>\n';
    rss += '    <title>EV Database Changelog</title>\n';
    rss += '    <description>Latest changes and updates to EV Database</description>\n';
    rss += '    <link>https://ev-database.com/changelog</link>\n';
    rss += `    <lastBuildDate>${new Date().toUTCString()}</lastBuildDate>\n`;
    
    for (const changelog of changelogs.slice(0, 20)) { // Limit to 20 most recent
      rss += '    <item>\n';
      rss += `      <title>${this.escapeXml(changelog.title)}</title>\n`;
      rss += `      <description>${this.escapeXml(this.formatAsPlainText(changelog))}</description>\n`;
      rss += `      <pubDate>${changelog.releaseDate.toUTCString()}</pubDate>\n`;
      rss += `      <guid>changelog-${changelog.version}</guid>\n`;
      rss += '    </item>\n';
    }
    
    rss += '  </channel>\n';
    rss += '</rss>';
    
    return rss;
  }

  /**
   * Format changelog as markdown
   */
  private formatAsMarkdown(
    changelog: FormattedChangelog,
    options: ChangelogFormatOptions
  ): string {
    let markdown = `## [${changelog.version}] - ${this.formatDate(changelog.releaseDate)}\n\n`;
    
    if (changelog.description) {
      markdown += `${changelog.description}\n\n`;
    }

    if (options.groupByCategory !== false) {
      // Group entries by category
      const groupedEntries = this.groupEntriesByCategory(changelog.entries);
      
      // Sort categories by importance
      const categoryOrder: CommitCategory[] = ['breaking', 'security', 'feature', 'bugfix', 'improvement', 'deprecated'];
      
      for (const category of categoryOrder) {
        const entries = groupedEntries[category];
        if (!entries || entries.length === 0) continue;
        
        const categoryInfo = CommitCategorizationService.getCategoryInfo(category);
        markdown += `### ${categoryInfo.emoji} ${categoryInfo.title}\n\n`;
        
        for (const entry of entries) {
          markdown += `- ${entry.title}`;
          
          if (options.includeCommitHashes && entry.commitHash) {
            markdown += ` (${entry.commitHash.substring(0, 7)})`;
          }
          
          markdown += '\n';
          
          if (entry.description && entry.description !== entry.title) {
            markdown += `  ${entry.description}\n`;
          }
        }
        
        markdown += '\n';
      }
    } else {
      // List all entries without grouping
      for (const entry of changelog.entries) {
        const categoryInfo = CommitCategorizationService.getCategoryInfo(entry.category);
        markdown += `- ${categoryInfo.emoji} **${categoryInfo.title}**: ${entry.title}`;
        
        if (options.includeCommitHashes && entry.commitHash) {
          markdown += ` (${entry.commitHash.substring(0, 7)})`;
        }
        
        markdown += '\n';
      }
    }

    if (options.includeMetadata) {
      markdown += '\n---\n';
      markdown += `*Generated on ${new Date().toISOString()}*\n`;
      const autoGenerated = changelog.entries.filter(e => e.isAutoGenerated).length;
      const manual = changelog.entries.length - autoGenerated;
      markdown += `*${changelog.entries.length} changes (${autoGenerated} auto-generated, ${manual} manual)*\n`;
    }

    return markdown.trim();
  }

  /**
   * Format changelog as plain text
   */
  private formatAsPlainText(changelog: FormattedChangelog): string {
    let text = `${changelog.title} - ${this.formatDate(changelog.releaseDate)}\n\n`;
    
    if (changelog.description) {
      text += `${changelog.description}\n\n`;
    }

    const groupedEntries = this.groupEntriesByCategory(changelog.entries);
    const categoryOrder: CommitCategory[] = ['breaking', 'security', 'feature', 'bugfix', 'improvement', 'deprecated'];
    
    for (const category of categoryOrder) {
      const entries = groupedEntries[category];
      if (!entries || entries.length === 0) continue;
      
      const categoryInfo = CommitCategorizationService.getCategoryInfo(category);
      text += `${categoryInfo.title}:\n`;
      
      for (const entry of entries) {
        text += `- ${entry.title}\n`;
      }
      
      text += '\n';
    }

    return text.trim();
  }

  /**
   * Get changelog data for a specific version
   */
  private async getChangelogData(version: string): Promise<FormattedChangelog | null> {
    const [changelog] = await db
      .select()
      .from(changelogs)
      .where(eq(changelogs.version, version))
      .limit(1);

    if (!changelog) {
      return null;
    }

    const entries = await db
      .select()
      .from(changelogEntries)
      .where(eq(changelogEntries.changelogId, changelog.id))
      .orderBy(changelogEntries.sortOrder);

    return {
      version: changelog.version,
      title: changelog.title,
      description: changelog.description || undefined,
      releaseDate: changelog.releaseDate,
      entries: entries.map(entry => ({
        category: entry.category as CommitCategory,
        title: entry.title,
        description: entry.description,
        commitHash: entry.gitCommitHash || undefined,
        isAutoGenerated: entry.isAutoGenerated,
      })),
    };
  }

  /**
   * Get all published changelog data
   */
  private async getAllChangelogData(): Promise<FormattedChangelog[]> {
    const changelogList = await db
      .select()
      .from(changelogs)
      .where(eq(changelogs.isPublished, true))
      .orderBy(desc(changelogs.releaseDate));

    const result: FormattedChangelog[] = [];

    for (const changelog of changelogList) {
      const entries = await db
        .select()
        .from(changelogEntries)
        .where(eq(changelogEntries.changelogId, changelog.id))
        .orderBy(changelogEntries.sortOrder);

      result.push({
        version: changelog.version,
        title: changelog.title,
        description: changelog.description || undefined,
        releaseDate: changelog.releaseDate,
        entries: entries.map(entry => ({
          category: entry.category as CommitCategory,
          title: entry.title,
          description: entry.description,
          commitHash: entry.gitCommitHash || undefined,
          isAutoGenerated: entry.isAutoGenerated,
        })),
      });
    }

    return result;
  }

  /**
   * Group entries by category
   */
  private groupEntriesByCategory(entries: FormattedChangelogEntry[]): Record<CommitCategory, FormattedChangelogEntry[]> {
    const groups: Record<CommitCategory, FormattedChangelogEntry[]> = {
      feature: [],
      bugfix: [],
      improvement: [],
      breaking: [],
      security: [],
      deprecated: [],
      chore: [],
      docs: [],
      test: [],
    };

    for (const entry of entries) {
      groups[entry.category].push(entry);
    }

    return groups;
  }

  /**
   * Format date for display
   */
  private formatDate(date: Date): string {
    return date.toISOString().split('T')[0];
  }

  /**
   * Escape XML special characters
   */
  private escapeXml(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }
}
