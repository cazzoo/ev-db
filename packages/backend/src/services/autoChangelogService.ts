import { db } from '../db';
import { gitCommits, changelogs, changelogEntries } from '../db/schema';
import { eq, desc, and, isNull, or } from 'drizzle-orm';
import { GitCommitParser } from './gitCommitParser';
import { CommitCategorizationService, CategorizedCommit, CommitCategory } from './commitCategorizationService';

export interface AutoChangelogResult {
  entriesCreated: number;
  commitsProcessed: number;
  changelogId: number;
  changelogVersion: string;
}

export class AutoChangelogService {
  private gitParser: GitCommitParser;
  private categorizer: CommitCategorizationService;
  private systemUserId: number = 1; // System user for auto-generated entries

  constructor(repoPath?: string) {
    this.gitParser = new GitCommitParser(repoPath);
    this.categorizer = new CommitCategorizationService();
  }

  /**
   * Continuously process new Git commits into changelog entries
   * This is the main method called by the scheduled job
   */
  async processNewCommits(): Promise<AutoChangelogResult> {
    try {
      console.log('üîÑ Auto-processing new Git commits...');

      // 1. Get new commits since last processing
      const newCommits = await this.getNewCommitsSinceLastProcessing();
      
      if (newCommits.length === 0) {
        console.log('‚ÑπÔ∏è No new commits to process');
        return {
          entriesCreated: 0,
          commitsProcessed: 0,
          changelogId: 0,
          changelogVersion: '',
        };
      }

      console.log(`üìù Found ${newCommits.length} new commits to process`);

      // 2. Categorize commits
      const categorizedCommits = this.categorizer.categorizeCommits(newCommits);
      const publicCommits = categorizedCommits.filter(commit => commit.isPublic);

      if (publicCommits.length === 0) {
        console.log('‚ÑπÔ∏è No public commits to add to changelog');
        // Still store commits in git_commits table for tracking
        await this.storeCommitsInDatabase(categorizedCommits);
        return {
          entriesCreated: 0,
          commitsProcessed: categorizedCommits.length,
          changelogId: 0,
          changelogVersion: '',
        };
      }

      // 3. Get or create "Unreleased" changelog
      const unreleasedChangelog = await this.getOrCreateUnreleasedChangelog();

      // 4. Store commits in git_commits table
      await this.storeCommitsInDatabase(categorizedCommits);

      // 5. Create changelog entries for public commits
      let entriesCreated = 0;
      for (const commit of publicCommits) {
        // Check if entry already exists for this commit
        const existingEntry = await db
          .select()
          .from(changelogEntries)
          .where(eq(changelogEntries.gitCommitHash, commit.hash))
          .limit(1);

        if (existingEntry.length === 0) {
          await db.insert(changelogEntries).values({
            changelogId: unreleasedChangelog.id,
            category: commit.category,
            title: commit.cleanTitle,
            description: commit.cleanDescription || commit.cleanTitle,
            sortOrder: await this.getNextSortOrder(unreleasedChangelog.id),
            gitCommitHash: commit.hash,
            isAutoGenerated: true,
            createdAt: new Date(),
          });
          entriesCreated++;
        }
      }

      // 6. Update changelog timestamp
      await db
        .update(changelogs)
        .set({ updatedAt: new Date() })
        .where(eq(changelogs.id, unreleasedChangelog.id));

      console.log(`‚úÖ Auto-processed ${entriesCreated} new changelog entries`);

      return {
        entriesCreated,
        commitsProcessed: categorizedCommits.length,
        changelogId: unreleasedChangelog.id,
        changelogVersion: unreleasedChangelog.version,
      };

    } catch (error) {
      console.error('‚ùå Error in auto-processing commits:', error);
      throw error;
    }
  }

  /**
   * Get new commits since last processing
   */
  private async getNewCommitsSinceLastProcessing(): Promise<any[]> {
    try {
      // Get the latest processed commit from database
      const [latestProcessed] = await db
        .select()
        .from(gitCommits)
        .orderBy(desc(gitCommits.date))
        .limit(1);

      let since: string | undefined;
      if (latestProcessed) {
        // Get commits since the latest processed commit
        since = latestProcessed.hash;
      }

      // Parse commits from Git
      const commits = await this.gitParser.parseCommits({
        since,
        maxCount: 100, // Limit to prevent overwhelming the system
        includeMerges: false,
      });

      // Filter out commits that are already in database
      const newCommits = [];
      for (const commit of commits) {
        const existing = await db
          .select()
          .from(gitCommits)
          .where(eq(gitCommits.hash, commit.hash))
          .limit(1);

        if (existing.length === 0) {
          newCommits.push(commit);
        }
      }

      return newCommits;

    } catch (error) {
      console.error('Error getting new commits:', error);
      // Fallback to recent commits
      return this.gitParser.parseCommits({
        maxCount: 10,
        includeMerges: false,
      });
    }
  }

  /**
   * Get or create the "Unreleased" changelog
   */
  private async getOrCreateUnreleasedChangelog(): Promise<any> {
    // Try to find existing "Unreleased" changelog
    const [existing] = await db
      .select()
      .from(changelogs)
      .where(eq(changelogs.version, 'Unreleased'))
      .limit(1);

    if (existing) {
      return existing;
    }

    // Create new "Unreleased" changelog
    const [newChangelog] = await db.insert(changelogs).values({
      version: 'Unreleased',
      title: 'Unreleased Changes',
      description: 'Latest changes from development. These will be included in the next release.',
      releaseDate: new Date(),
      isPublished: true, // Make it visible
      publishedAt: new Date(),
      createdBy: this.systemUserId,
      createdAt: new Date(),
      updatedAt: new Date(),
    }).returning();

    console.log('üìã Created new "Unreleased" changelog');
    return newChangelog;
  }

  /**
   * Store commits in git_commits table for tracking
   */
  private async storeCommitsInDatabase(commits: CategorizedCommit[]): Promise<void> {
    for (const commit of commits) {
      try {
        // Check if commit already exists
        const existing = await db
          .select()
          .from(gitCommits)
          .where(eq(gitCommits.hash, commit.hash))
          .limit(1);

        if (existing.length === 0) {
          await db.insert(gitCommits).values({
            hash: commit.hash,
            shortHash: commit.shortHash,
            author: commit.author,
            authorEmail: commit.authorEmail,
            date: commit.date,
            message: commit.message,
            subject: commit.subject,
            body: commit.body,
            filesChanged: JSON.stringify(commit.filesChanged),
            insertions: commit.insertions,
            deletions: commit.deletions,
            category: commit.category,
            isBreakingChange: commit.isBreakingChange,
            isPublic: commit.isPublic,
            processedAt: new Date(),
            createdAt: new Date(),
          });
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è Failed to store commit ${commit.shortHash}:`, error);
      }
    }
  }

  /**
   * Get next sort order for changelog entries
   */
  private async getNextSortOrder(changelogId: number): Promise<number> {
    const [maxOrder] = await db
      .select({ maxOrder: changelogEntries.sortOrder })
      .from(changelogEntries)
      .where(eq(changelogEntries.changelogId, changelogId))
      .orderBy(desc(changelogEntries.sortOrder))
      .limit(1);

    return (maxOrder?.maxOrder || 0) + 1;
  }

  /**
   * Create a new versioned changelog from unreleased entries
   */
  async createVersionedChangelog(version: string, title?: string): Promise<number> {
    try {
      console.log(`üöÄ Creating versioned changelog: ${version}`);

      // Get unreleased changelog
      const [unreleasedChangelog] = await db
        .select()
        .from(changelogs)
        .where(eq(changelogs.version, 'Unreleased'))
        .limit(1);

      if (!unreleasedChangelog) {
        throw new Error('No unreleased changelog found');
      }

      // Get unreleased entries
      const unreleasedEntries = await db
        .select()
        .from(changelogEntries)
        .where(eq(changelogEntries.changelogId, unreleasedChangelog.id))
        .orderBy(changelogEntries.sortOrder);

      if (unreleasedEntries.length === 0) {
        throw new Error('No unreleased entries to create changelog from');
      }

      // Create new versioned changelog
      const [newChangelog] = await db.insert(changelogs).values({
        version,
        title: title || `Release ${version}`,
        description: `Release containing ${unreleasedEntries.length} changes from development.`,
        releaseDate: new Date(),
        isPublished: true,
        publishedAt: new Date(),
        createdBy: this.systemUserId,
        createdAt: new Date(),
        updatedAt: new Date(),
      }).returning();

      // Copy entries to new changelog
      for (const entry of unreleasedEntries) {
        await db.insert(changelogEntries).values({
          changelogId: newChangelog.id,
          category: entry.category,
          title: entry.title,
          description: entry.description,
          sortOrder: entry.sortOrder,
          gitCommitHash: entry.gitCommitHash,
          isAutoGenerated: entry.isAutoGenerated,
          createdAt: new Date(),
        });
      }

      // Clear unreleased entries
      await db
        .delete(changelogEntries)
        .where(eq(changelogEntries.changelogId, unreleasedChangelog.id));

      console.log(`‚úÖ Created versioned changelog ${version} with ${unreleasedEntries.length} entries`);
      return newChangelog.id;

    } catch (error) {
      console.error('‚ùå Error creating versioned changelog:', error);
      throw error;
    }
  }

  /**
   * Get statistics about auto-processing
   */
  async getProcessingStats(): Promise<{
    totalCommitsTracked: number;
    publicCommitsTracked: number;
    autoGeneratedEntries: number;
    unreleasedEntries: number;
    lastProcessedCommit?: any;
  }> {
    const [totalCommits] = await db
      .select({ count: gitCommits.id })
      .from(gitCommits);

    const [publicCommits] = await db
      .select({ count: gitCommits.id })
      .from(gitCommits)
      .where(eq(gitCommits.isPublic, true));

    const [autoEntries] = await db
      .select({ count: changelogEntries.id })
      .from(changelogEntries)
      .where(eq(changelogEntries.isAutoGenerated, true));

    const [unreleasedChangelog] = await db
      .select()
      .from(changelogs)
      .where(eq(changelogs.version, 'Unreleased'))
      .limit(1);

    let unreleasedCount = 0;
    if (unreleasedChangelog) {
      const [unreleasedEntries] = await db
        .select({ count: changelogEntries.id })
        .from(changelogEntries)
        .where(eq(changelogEntries.changelogId, unreleasedChangelog.id));
      unreleasedCount = unreleasedEntries.count;
    }

    const [lastProcessed] = await db
      .select()
      .from(gitCommits)
      .orderBy(desc(gitCommits.processedAt))
      .limit(1);

    return {
      totalCommitsTracked: totalCommits.count,
      publicCommitsTracked: publicCommits.count,
      autoGeneratedEntries: autoEntries.count,
      unreleasedEntries: unreleasedCount,
      lastProcessedCommit: lastProcessed,
    };
  }
}
